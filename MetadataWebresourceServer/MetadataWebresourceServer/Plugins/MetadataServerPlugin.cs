// <copyright file="RetrieveMultiplePlugin.cs" company="">
// Copyright (c) 2014 All Rights Reserved
// </copyright>
// <author></author>
// <date>10/23/2014 7:09:08 PM</date>
// <summary>Implements the RetrieveMultiplePlugin Plugin.</summary>
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.1
// </auto-generated>
namespace SparkleXrm.Plugins.MetadataWebresourceServer
{
    using System;
    using System.ServiceModel;
    using Microsoft.Xrm.Sdk;
    using Microsoft.Xrm.Sdk.Query;
    using System.Text.RegularExpressions;
    using System.Text;
    using System.Collections.Generic;
    using System.Linq;
    using Microsoft.Xrm.Sdk.Metadata.Query;
    using Microsoft.Xrm.Sdk.Messages;
    using Microsoft.Xrm.Sdk.Metadata;
    using System.Runtime.Serialization.Json;
    using System.IO;
    using Microsoft.Crm.Sdk.Messages;
    
    /// <summary>
    /// RetrieveMultiplePlugin Plugin.
    /// </summary>    
    public class MetadataServerPlugin: Plugin
    {
        private string _unsecureconfig;
        private string _secureconfig;
        /// <summary>
        /// Initializes a new instance of the <see cref="MetadataServerPlugin"/> class.
        /// </summary>
        public MetadataServerPlugin(string unsecure, string secure)
            : base(typeof(MetadataServerPlugin))
        {
            _unsecureconfig = unsecure;
            _secureconfig = secure;
            base.RegisteredEvents.Add(new Tuple<int, string, string, Action<LocalPluginContext>>(40, "RetrieveMultiple", "webresource", new Action<LocalPluginContext>(ExecuteRetrieveMultiplePlugin)));

            // Note : you can register for more events here if this plugin is not specific to an individual entity and message combination.
            // You may also need to update your RegisterFile.crmregister plug-in registration file to reflect any change.
        }

        /// <summary>
        /// Executes the plug-in.
        /// </summary>
        /// <param name="localContext">The <see cref="LocalPluginContext"/> which contains the
        /// <see cref="IPluginExecutionContext"/>,
        /// <see cref="IOrganizationService"/>
        /// and <see cref="ITracingService"/>
        /// </param>
        /// <remarks>
        /// For improved performance, Microsoft Dynamics CRM caches plug-in instances.
        /// The plug-in's Execute method should be written to be stateless as the constructor
        /// is not called for every invocation of the plug-in. Also, multiple system threads
        /// could execute the plug-in at the same time. All per invocation state information
        /// is stored in the context. This means that you should not use global variables in plug-ins.
        /// </remarks>
        protected void ExecuteRetrieveMultiplePlugin(LocalPluginContext localContext)
        {
            if (localContext == null)
            {
                throw new ArgumentNullException("localContext");
            }
            try
            {
                var service = localContext.OrganizationService;
                var trace = localContext.TracingService;

                // Check the depth - we don't want to run on child queries
                if (localContext.PluginExecutionContext.Depth > 1)
                    return;
                
                // Exract the search criteria 
                QueryBase query = (QueryBase)localContext.PluginExecutionContext.InputParameters["Query"];
                Type queryType = query.GetType();
                if (queryType == typeof(QueryExpression))
                {
                    var queryExpression = (QueryExpression)query;
                    var webresourceName = GetMetadataRequestWebresourceName(queryExpression);
                    if (webresourceName==null)
                        return;

                    // Get the requested LCID
                    var lcidString = webresourceName.Substring(webresourceName.Length - 7, 4);
                    int lcid = 0;

                    if (!int.TryParse(lcidString, out lcid))
                        return;

                    // Is there a webresource with this LCID in the system?
                    var outputCollection = (EntityCollection)localContext.PluginExecutionContext.OutputParameters["BusinessEntityCollection"];
                    var templateEntity = outputCollection;
                    if (outputCollection.Entities.Count==0)
                    {
                        // No webresource found, so get the template resource file for the base language
                        queryExpression.Criteria.Conditions[0].Values[0] = webresourceName.Replace("_" + lcid.ToString(), "_" + GetDefaultLCID(service).ToString());
                        templateEntity = service.RetrieveMultiple(query);
                        if (templateEntity.Entities.Count != 1)
                            return;
                    }

                    var templateData = System.Convert.FromBase64String(templateEntity.Entities[0].GetAttributeValue<string>("content"));
                    var templateText = System.Text.Encoding.UTF8.GetString(templateData);    
                    var outputText = ParseTemplate(templateText, lcid, service);
                                        
                    var scriptBytes = System.Text.Encoding.UTF8.GetBytes(outputText);
                    Entity output = new Entity("webresource");
                    output["name"] = webresourceName;
                    output["content"] = System.Convert.ToBase64String(scriptBytes);
                    output["webresourcetype"] = new OptionSetValue(3);
                    outputCollection.Entities.Clear();
                    outputCollection.Entities.Add(output);
                }
            }
            catch (Exception ex)
            {
                if (_unsecureconfig == "Debug")
                {
                    throw new InvalidPluginExecutionException("Could not create metadata webresouces : " + ex.Message, ex);
                }
            }
        }

        /// <summary>
        /// Determine if this is a request for a metadata resource.
        /// </summary>
        /// <param name="queryExpression"></param>
        /// <returns>Name of requested webresource or null if not a metadata request</returns>
        private static string GetMetadataRequestWebresourceName(QueryExpression queryExpression)
        {
            // Get condition
            string webresourceName = null;
            if (queryExpression.EntityName != "webresource")
            {
                return webresourceName;
            }

            if (queryExpression.Criteria == null || queryExpression.Criteria.Conditions.Count != 1 || queryExpression.Criteria.Conditions[0].AttributeName != "name")
            {
                return webresourceName;
            }

            webresourceName = (string)queryExpression.Criteria.Conditions[0].Values[0];

            // Is this a request for a metadata server page
            int length = webresourceName.Length;

            // Metadata server webresources must have the name 'SomeName.metadata_xxxx.js' where xxxx is in the language LCID
            var isMetadataRequest = webresourceName.EndsWith(".js") && length > 17
                                    && webresourceName.Substring(length - 17, 10) == ".metadata_";
                                    
            if (!isMetadataRequest)
                return null;

            return webresourceName;
        }

        /// <summary>
        /// Check that the requested LCID is a provisioned language - otherwise return the default LCID
        /// </summary>
        /// <param name="service"></param>
        /// <param name="lcid"></param>
        /// <returns></returns>
        private static int CheckLcid(IOrganizationService service, int lcid)
        {
            // Find the provisioned languages and check that we are requesting one - otherwise fallback to the default language
            RetrieveAvailableLanguagesRequest langRequest = new RetrieveAvailableLanguagesRequest();
            var langResponse = (RetrieveAvailableLanguagesResponse)service.Execute(langRequest);
            if (!langResponse.LocaleIds.Contains(lcid))
            {
                lcid = GetDefaultLCID(service);
            }
            return lcid;
        }

        private static int GetDefaultLCID(IOrganizationService service)
        {
            // Get the orgs default language
            FetchExpression languageQuery = new FetchExpression(@"<fetch version=""1.0"" output-format=""xml-platform"" mapping=""logical"" distinct=""false"" count=""1"" >
                                                                                <entity name=""organization"" >
                                                                                    <attribute name=""languagecode"" />
                                                                                </entity>
                                                                            </fetch>");
            var orgSettings = service.RetrieveMultiple(languageQuery);
            var lcid = orgSettings.Entities[0].GetAttributeValue<int>("languagecode");
            return lcid;
        }

        /// <summary>
        /// Get a list of tokens in the template webresource and set the values based on the LCID
        /// </summary>
        /// <param name="template"></param>
        /// <param name="lcid"></param>
        /// <param name="service"></param>
        /// <returns></returns>
        public string ParseTemplate(string template, int lcid, IOrganizationService service)
        {
            lcid = CheckLcid(service, lcid);

            // Remove the comment start and end tags
            template = template.Replace("/*metadata", "");
            template = template.Replace("metadata*/", "");

            Dictionary<string, Dictionary<string, HashSet<string>>> entities;
            // Get a list of tokens and a consolidated list of metadata that is requested
            List<MetadataExpression> expressions = ExtractTokens(template, out entities);

            // Get the metadata
            var metadataResponse = GetEntityMetadata(service, entities, lcid);

            // Set the token values in the template based on the requested metadata
            SetValues(expressions, metadataResponse, service);

            return CreateOutput(template, expressions);
        }

        /// <summary>
        /// Add the expression values into the template to create the output webresource that will be cached on the client
        /// </summary>
        /// <param name="template"></param>
        /// <param name="expressions"></param>
        /// <returns></returns>
        private static string CreateOutput(string template, List<MetadataExpression> expressions)
        {
            // Replace the values in the template
            StringBuilder output = new StringBuilder();
            int sourcePosition = 0;
            foreach (MetadataExpression match in expressions)
            {
                output.Append(template.Substring(sourcePosition, match.StartIndex - sourcePosition));
                output.Append(match.Value);
                sourcePosition = match.StartIndex + match.Length;
            }

            // Add the final text
            output.Append(template.Substring(sourcePosition));


            StringWriter writer = new StringWriter();

            output.Append(writer.ToString());
            return output.ToString();
        }

        /// <summary>
        /// Extract all the tokens in the template that need replacing with actual values
        /// </summary>
        /// <param name="template"></param>
        /// <param name="entities"></param>
        /// <returns></returns>
        private static List<MetadataExpression> ExtractTokens(string template,  out Dictionary<string, Dictionary<string, HashSet<string>>> entities)
        {
            List<MetadataExpression> expressions = new List<MetadataExpression>();
            Regex expression = new Regex(@"\<@([\w\.\>\<\/\-\=\""\'\s\{\}]+)@\>");
            var matches = expression.Matches(template);

            foreach (Match match in matches)
            {
                // Get a list of entities, attributes and metatadata to retrieve
                MetadataExpression expr = new MetadataExpression(match.Groups[1].Value, match.Index, match.Length);
                expressions.Add(expr);
            }

            // Analysis of the expressions
            entities = new Dictionary<string, Dictionary<string, HashSet<string>>>();

            foreach (var expr in expressions)
            {
                switch (expr.ExpressionType)
                {
                    case TokenExpressionType.EntityMetadata:
                        if (!entities.ContainsKey(expr.Entity))
                        {
                            entities.Add(expr.Entity, new Dictionary<string, HashSet<string>>());
                        }
                        var attributes = entities[expr.Entity];

                        if (!attributes.ContainsKey(expr.Attribute))
                        {
                            attributes.Add(expr.Attribute, new HashSet<string>());
                        }
                        var properties = attributes[expr.Attribute];
                        if (!properties.Contains(expr.PropertyName))
                            properties.Add(expr.PropertyName);

                        break;
                }
            }
            return expressions;
        }

        /// <summary>
        /// Evaluate the expressions and set their values based on the metadata response
        /// </summary>
        /// <param name="expressions"></param>
        /// <param name="metadataResponse"></param>
        /// <param name="service"></param>
        private static void SetValues(List<MetadataExpression> expressions, RetrieveMetadataChangesResponse metadataResponse, IOrganizationService service)
        {
            string formatString = "";
            foreach (var expr in expressions)
            {
                if (expr.ExpressionType == TokenExpressionType.EntityMetadata)
                {
                    var entityMetadata = metadataResponse.EntityMetadata.Where(m => m.LogicalName == expr.Entity).FirstOrDefault();
                    if (entityMetadata == null)
                        continue;

                    string propertyName = expr.PropertyName;
                    try
                    {
                        if (expr.Attribute == MetadataExpression.EntityProperties)
                        {
                            // Get properties from entity
                            object value = entityMetadata.GetType().GetProperty(expr.PropertyName).GetValue(entityMetadata);
                            expr.SerialiseValue(value);
                        }
                        else
                        {
                            // Get property from attribute
                            var attributeMetadata = entityMetadata.Attributes.Where(m => m.LogicalName == expr.Attribute).FirstOrDefault();
                            object value = attributeMetadata.GetType().GetProperty(expr.PropertyName).GetValue(attributeMetadata);
                            expr.SerialiseValue(value);

                        }
                        if (!string.IsNullOrWhiteSpace(formatString))
                            expr.Value = String.Format(formatString, expr.Value, expr.Entity, expr.Attribute, expr.PropertyName);
                    }
                    catch (Exception ex)
                    {
                        expr.SerialiseValue(ex.ToString());
                    }
                }
                else if (expr.ExpressionType==TokenExpressionType.Function)
                {
                    switch (expr.FunctionName.ToLower())
                    {
                        case "fetch":
                            try
                            {
                                // Execute the fetchxml
                                FetchExpression query = new FetchExpression(expr.Paramaters);
                                var response = service.RetrieveMultiple(query);
                                expr.SerialiseValue(response);
                            }
                            catch (Exception ex)
                            {
                                expr.SerialiseValue(ex.Message);
                            }
                            break;

                        case "format":
                            // Use a format string
                            formatString = expr.Paramaters;
                            break;

                    }

                }


            }
        }

       

        private RetrieveMetadataChangesResponse GetEntityMetadata(IOrganizationService service, Dictionary<string, Dictionary<string, HashSet<string>>> entities, int lcid)
        {
            
            MetadataFilterExpression entityFilter = new MetadataFilterExpression(LogicalOperator.Or);
            MetadataPropertiesExpression entityProperties = new MetadataPropertiesExpression{AllProperties = false};
            entityProperties.PropertyNames.Add("Attributes"); // By default query the properties that match the query

            MetadataFilterExpression attributesFilter = new MetadataFilterExpression(LogicalOperator.Or);
            MetadataPropertiesExpression attributeProperties = new MetadataPropertiesExpression{AllProperties = false};
            LabelQueryExpression labelQuery = new LabelQueryExpression();
            labelQuery.MissingLabelBehavior = 1;
            labelQuery.FilterLanguages.Add(lcid);

           

            HashSet<string> attributePropertyNamesAdded = new HashSet<string>();
            HashSet<string> entityPropertyNamesAdded = new HashSet<string>();

            foreach (var entity in entities.Keys)
            {
                entityFilter.Conditions.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, entity));
                var attributes = entities[entity];

                foreach (var attribute in attributes.Keys)
                {
                    if (attribute != MetadataExpression.EntityProperties)
                    {
                        // Query attribute properties
                        MetadataFilterExpression attributeFilter = new MetadataFilterExpression(LogicalOperator.And);
                        attributesFilter.Filters.Add(attributeFilter);
                        attributeFilter.Conditions.Add(new MetadataConditionExpression("EntityLogicalName", MetadataConditionOperator.Equals, entity));
                        attributeFilter.Conditions.Add(new MetadataConditionExpression("LogicalName", MetadataConditionOperator.Equals, attribute));

                        var properties = attributes[attribute];
                        foreach (var property in properties)
                        {
                            if (!attributePropertyNamesAdded.Contains(property))
                            {
                                attributeProperties.PropertyNames.Add(property);
                                attributePropertyNamesAdded.Add(property);
                            }
                        }
                    }
                    else
                    {
                        // Query entity properties
                        var properties = attributes[attribute];
                        foreach (var property in properties)
                        {
                            if (!entityPropertyNamesAdded.Contains(property))
                            {
                                entityProperties.PropertyNames.Add(property);
                                entityPropertyNamesAdded.Add(property);
                            }
                        }
                    }
                }
            }

            EntityQueryExpression entityQueryExpression = new EntityQueryExpression()
            {
                Criteria = entityFilter,
                Properties = entityProperties,
                AttributeQuery = new AttributeQueryExpression()
                {
                    Criteria = attributesFilter,
                    Properties = attributeProperties
                },
                LabelQuery = labelQuery

            };

            RetrieveMetadataChangesRequest retrieveMetadataChangesRequest = new RetrieveMetadataChangesRequest()
            {
                Query = entityQueryExpression
             
            };

            var response = (RetrieveMetadataChangesResponse)service.Execute(retrieveMetadataChangesRequest);

           

            return response;

        }
       

    }
}
